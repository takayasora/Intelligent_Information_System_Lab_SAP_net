# sequential SAP-net



# ネットワーク描画のテスト
- 作成したいネットワークのつながりを表したクロス表をsqlite3を用いて作成

```python
table_ex = [
    [0, 0.2, 3, 0, 0, 0],
    [0.2, 0, 2, 4, 6, 0],
    [3, 2, 0, 0, 0, 3],
    [0, 4, 0, 0, 0, 0],
    [0, 6, 0, 0, 0, 0],
    [0, 0, 3, 0, 0, 0]
]
```
クロス表内の値が0以上である場合、ノードが繋がっているかつ、その値の距離が設定される

- networkxを用いて空のネットワーク図の作成
- クロス表のつながりを基にノードとエッジを追加



# SQLのテスト
- ネットワーク図の値を保持する必要があるため、SQLiteを介しての値を保持・出力・更新などのテストを行う
  - 値の保持
  
    テーブルを作成したのち、配列（データ）を定義し、データを挿入していく

    ```python
        data = [["Adata",0, 1, 1, 0, 0, 0],
            ["Bdata",1, 0, 1, 1, 1, 0],
            ["Cdata",1, 1, 0, 0, 0, 1],
            ["Ddata",0, 1, 0, 0, 0, 0],
            ["Edata",0, 1, 0, 0, 0, 0],
            ["Fdata",0, 0, 1, 0, 0, 0]]
    ```

    上記のクロス表をテーブルに保持

  - 値の取得
    
    SQLの機能のカーソルを用いて、SQL内のデータを取得し、データフレームへ保持・表示を行う

    データを取得してDataFrameに格納したのち、データを取得・表示


    <img src = "https://i.gyazo.com/aace95992f664bec4cabc7d3ea48ce41.png">

    "data"列をデータフレームのインデックスに設定し、不要な"id"列を削除したのちに、データの表示

    <img src="https://i.gyazo.com/afb0f8222ebc23018bad7f513dfb6b21.png">


# NetworkXとSQLとのデータ送受信テスト
- ネットワーク図の値を保持する必要があるため、SQLiteを介しての値を保持・出力・更新などのテストを行う
  
- 今回のプログラムでは、値の取得を行い、実際にNetworkXを用いて可視化を行っている。
- このプログラムが完成すれば、SQLでデータを保存し、それらを取得、可視化までが完成していることを表す。

- また、NetworkXでの可視化プログラムは、配列の入力からデータフレームの入力に変更している。
  
- 要は、SQLにデータを保持したのち、データを取得し、そのデータの可視化&そのデータを用いてNetworkXでのネットワーク図の作成を行う


# パスの重みのテスト

- クロス表内のパスの重みの判定を0の時、繋がっていない、0以外の時、繋がっているようにする
- またパスの重みをネットワーク図のパスに表示する
  
  - パスの重みが各ノードに設定されたSQLを用意
  ```python
      data = [["Adata",0, 0.2, 0.5, 0, 0, 0],
            ["Bdata",0.2, 0, 0.3, 0.4, 0.1, 0],
            ["Cdata",0.5, 0.3, 0, 0, 0, 0.6],
            ["Ddata",0, 0.4, 0, 0, 0, 0],
            ["Edata",0, 0.1, 0, 0, 0, 0],
            ["Fdata",0, 0, 0.6, 0, 0, 0]]
  ```
  - SQLのセットアップ・データの取得・表示・可視化を行う
  - ネットワーク図を表示させるときに、distance(距離)を設定
  - 距離はSQLに保存されている各ノードを探索し、パスの値が0以上のときに、エッジの属性（重み）として追加
  
# 活性値の表示テスト
- クロス表内の同じノード同士の交点（同値交点）に各ノードの活性値を保存
- ノードの大きさで活性値の大小を可視化
- 閾値を実装した際に、活性値が閾値より大きい際に、選択される知識のネットワークに保存
- 複数のノードの活性値が閾値を超え、選択された場合、その中からランダムで選択される or 一番活性値が高い知識が選択される

とりあえず、ネットワーク図に活性値をノードの大きさとして表示する

```python
def NetworkX(df):
    G = nx.DiGraph()

    # ノードを追加
    nodes = df.columns
    for node in nodes:
        G.add_node(node)

    # エッジを追加
    for i in range(len(nodes)):
        for j in range(len(nodes)):
            distance = df.iloc[i, j]
            if i != j:  # iとjが同じでない場合のみエッジを追加
                if distance != 0.0:
                    G.add_edge(nodes[i], nodes[j], weight=distance)
            else:
                node_size = distance*1000  # iとjが同じ場合、ノードの大きさを設定
                G.nodes[nodes[i]]['size'] = node_size
```

上記のコードでクロス表の同値交点ではノードの大きさとして設定し、違う場所（パスの重み）であるところはエッジに属性付与し、距離を表示

<img src = "https://i.gyazo.com/7afa09eafd9f89e505cc53c196c1c39a.png" width = 400px>

# 活性値の視認性向上テスト
- 適当に閾値を決める。
- クロス表内のノードの活性値を参照した際に、ノードの大きさを決める
- 閾値よりも活性値が大きいとき、ノードの色を赤色に設定する
```python
            else:
                node_size = distance*1000  # iとjが同じ場合、ノードの大きさを設定
                G.nodes[nodes[i]]['size'] = node_size
                #閾値の視認性を高める
                threshold = 3.0
                print(distance,threshold,distance>threshold)
                if(distance>threshold):
                    node_color = 'red'  # ノードの色を赤に設定
                    G.nodes[nodes[i]]['color'] = node_color
```
<img src = "https://i.gyazo.com/f127abf6812b2281049d4f80e38b8e7a.png" width = 400>

閾値を超えたノードの可視化に成功

<!--閾値を関数内に定義でいいの？
閾値を自動調整や計算式に基づいて決めるなら違う方法が必要
-->

# 活性値拡散のテスト1
- メインの活性値の拡散について実装

とりあえずは、全拡散を用いて拡散する

## 全拡散
- 一度ノードに刺激が入ったら、それに連なっていくノードすべてに拡散
- 拡散の回数制限などを設けないと、１度の刺激に対してほぼ永遠と拡散し続けてしまう→発散

    発散を防ぐための方法
  - 拡散回数を制限
    
    刺激を受けたノードからn回拡散したら拡散停止 or 一定の距離拡散したら停止 

  - 逆流防止

    活性値が拡散する際に、一度通ったネットワークの経路を２度目は通らないようにする


# 


<!--
# クロス表内の値を変えるテスト
- クロス表内の活性値を更新する
  
  任意のノードを選択し、そのノードに対応する活性値をネットワークのつながりを基に更新する
  ノードiが活性化され、活性値が$a_i$であった場合、隣接するノードjに活性値が拡散されるとき、次式の$\eta_i$の分だけ活性値が伝播する

  更新式
  $\eta_i=\displaystyle\frac{1}{N}A_iexp(-\omega_{ij})$

  - Nはノードが持つパスの数
  - $A_i$は活性値
  - $\omega$はパスの重み（パスの長さ）

  
  <img src = "https://i.gyazo.com/09386be32ad51861b6ffb53206db1fc3.jpg" width = "310">

  
- 上記図のように、ネットワーク内にサイクルが存在する場合
    - ノード$\pi_i$から活性値が拡散されきた重み$\omega_{ij}$と$\omega_{ik}$のパスは、ノード$\pi_j$と$\pi_k$から見れば入力パスであり、その直後の活性値の拡散には用いない。すなわち、$\pi_j$と$\pi_k$は重$\omega_{jk}$のパスを通じて拡散しあう。拡散しあう前に、$\pi_j$と$\pi_k$の活性値を比較し、大きい方から小さいほうに差分計算を行う。

# 活性値の拡散のテスト

- 初めに、全拡散を用いて拡散させていく。また拡散の2重ループ、適当な閾値、拡散の計算式を実装していく。
  - 
-->


